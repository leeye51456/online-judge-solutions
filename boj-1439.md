# 뒤집기

## 문제·풀이 정보

- 문제 번호: [1439](https://www.acmicpc.net/problem/1439)
- 제목: 뒤집기
- 풀이 당시 난이도: Silver V ([solved.ac](https://solved.ac/) 제공)
- 분류: 그리디 알고리즘
- 풀이 언어: [Python3](https://github.com/leeye51456/online-judge-solutions/blob/master/boj-1439.py)
- 풀이 날짜: 2020-09-02

-----

## 생각의 흐름에 따른 풀이 과정

### 첫 번째 생각

- 바뀌는 지점(0→1, 1→0)을 체크해서 더 적은 쪽을 선택해도 될까?
- 예: `1010101`
  - 여기서 `10`도 3번, `01`도 3번 나타난다.
  - 그래서 어느 쪽을 선택해야 하지?
  - 0의 개수가 더 적으므로 0을 1로 바꾸는 게 행동 횟수가 1회 적다.

### 두 번째 생각

- 그렇다면, 숫자가 조금 나오는 쪽을 선택하는 게 맞지 않을까?
- 좀 더 구체적으로, 연속되는 숫자 집단(`/0+/`, `/1+/`) 개수가 적은 쪽을 뒤집자.
- 예: `11001100110011`
  - 입력 문자열을 순회하면서 현재 탐색 중인 숫자(digit)가 바뀔 때마다, 새로 시작되는 숫자 집단 개수를 1씩 늘린다.
- 혹시, 뒤집었던 부분을 또 뒤집는 식으로 횟수가 더 적은 풀이가 나올 수 있을까?
  - `/a+b+a+b+a+/`에서 가운데 `/b+a+b+/`를 `/a+/`로 만들 때, 두 가지 방법이 존재하는데, 둘 다 2회 뒤집음.
    - `/b+/`를 각각 뒤집는 방법
    - 가운데 `/a+/`를 뒤집은 뒤에, 한 덩어리가 된 `/b+/`를 뒤집는 방법 (또는 가운데 `/b+a+b+/`를 뒤집으면 생기는 `/b+/`를 다시 뒤집는 방법)
  - **수학적으로는 어떻게 설명해야 하나?** 이걸 풀어 내는 게 가장 확실한데, 쉽지 않다.

### 풀이 후 생각

- 입력받은 문자열의 첫 글자를 떼어 놓을 필요 없이, 애초에 현재 보고 있는 문자를 `0`도 `1`도 아닌 것(예: 빈 문자열)으로 초기화해 놓으면 풀이가 조금 더 깔끔해질 것 같다.
- 정규표현식으로 풀이 길이를 짧게 할 수는 있는데, 시간은 2배 정도 걸릴 것 같다. (`/(0+)/g` 그룹 개수 구하고 `/(1+)/g` 그룹 개수 구하고 적은 쪽 선택)
